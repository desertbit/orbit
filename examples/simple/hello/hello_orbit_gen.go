/* code generated by orbit */
package hello

import (
	context "context"
	errors "errors"
	fmt "fmt"
	closer "github.com/desertbit/closer/v3"
	codec "github.com/desertbit/orbit/pkg/codec"
	orbit "github.com/desertbit/orbit/pkg/orbit"
	packet "github.com/desertbit/orbit/pkg/packet"
	validator "github.com/go-playground/validator/v10"
	io "io"
	net "net"
	strings "strings"
	sync "sync"
	time "time"
)

var (
	_ context.Context
	_ = errors.New("")
	_ net.Conn
	_ time.Time
	_ sync.Locker
	_ orbit.Conn
	_ = fmt.Sprint()
	_ = strings.Builder{}
	_ = io.EOF
	_ validator.StructLevel
	_ codec.Codec
	_ = packet.MaxSize
	_ closer.Closer
)

//##############//
//### Errors ###//
//##############//

var ErrClosed = errors.New("closed")

func _orbitErrCodeCheck(err error) error {
	return err
}
func _errToOrbitErrCodeCheck(err error) error {
	return err
}
func _valErrCheck(err error) error {
	if vErrs, ok := err.(validator.ValidationErrors); ok {
		var errMsg strings.Builder
		for _, err := range vErrs {
			errMsg.WriteString(fmt.Sprintf("-> name: '%s', value: '%s', tag: '%s'", err.StructNamespace(), err.Value(), err.Tag()))
		}
		return errors.New(errMsg.String())
	}
	return err
}

var validate = validator.New()

//#############//
//### Types ###//
//#############//

type Info struct {
	Name    string `validate:"required,min=1"`
	Age     int    `validate:"required,min=1,max=155"`
	Locale  string `validate:"required,len=5"`
	Address string `validate:"omitempty"`
}

type SayHiArgs struct {
	Name string `validate:"required,min=1"`
}

//msgp:ignore TimeReadChan
type TimeReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newTimeReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *TimeReadChan {
	return &TimeReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *TimeReadChan) Read() (arg time.Time, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Var(arg, "required")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore TimeWriteChan
type TimeWriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newTimeWriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *TimeWriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &TimeWriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *TimeWriteChan) Write(ret time.Time) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//################//
//### Services ###//
//################//

// Hello  ---------------------
// Service
const (
	ServiceHello   = "Hello"
	HelloSayHi     = "SayHi"
	HelloWhoAreYou = "WhoAreYou"
	HelloClockTime = "ClockTime"
)

type HelloClientCaller interface {
	// Calls
	SayHi(ctx context.Context, args *SayHiArgs) (err error)
	// Streams
	ClockTime(ctx context.Context) (ret *TimeReadChan, err error)
}

type HelloClientHandler interface {
	// Calls
	WhoAreYou(ctx context.Context, s *orbit.Session) (ret *Info, err error)
}

type HelloServerCaller interface {
	// Calls
	WhoAreYou(ctx context.Context) (ret *Info, err error)
}

type HelloServerHandler interface {
	// Calls
	SayHi(ctx context.Context, s *orbit.Session, args *SayHiArgs) (err error)
	// Streams
	ClockTime(s *orbit.Session, ret *TimeWriteChan)
}

type helloClient struct {
	h HelloClientHandler
	s *orbit.Session
}

func RegisterHelloClient(s *orbit.Session, h HelloClientHandler) HelloClientCaller {
	cc := &helloClient{h: h, s: s}
	s.RegisterCall(ServiceHello, HelloWhoAreYou, cc.whoAreYou)
	return cc
}

func (v1 *helloClient) SayHi(ctx context.Context, args *SayHiArgs) (err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	_, err = v1.s.Call(ctx, ServiceHello, HelloSayHi, args)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *helloClient) whoAreYou(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	ret, err := v1.h.WhoAreYou(ctx, s)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	r = ret
	return
}

func (v1 *helloClient) ClockTime(ctx context.Context) (ret *TimeReadChan, err error) {
	stream, err := v1.s.OpenStream(ctx, ServiceHello, HelloClockTime)
	if err != nil {
		return
	}
	ret = newTimeReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret.OnClosing(stream.Close)
	return
}

type helloServer struct {
	h HelloServerHandler
	s *orbit.Session
}

func RegisterHelloServer(s *orbit.Session, h HelloServerHandler) HelloServerCaller {
	cc := &helloServer{h: h, s: s}
	s.RegisterCall(ServiceHello, HelloSayHi, cc.sayHi)
	s.RegisterStream(ServiceHello, HelloClockTime, cc.clockTime)
	return cc
}

func (v1 *helloServer) WhoAreYou(ctx context.Context) (ret *Info, err error) {
	ctx, cancel := context.WithTimeout(ctx, 500000000*time.Nanosecond)
	defer cancel()
	retData, err := v1.s.Call(ctx, ServiceHello, HelloWhoAreYou, nil)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	err = retData.Decode(&ret)
	if err != nil {
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *helloServer) sayHi(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	var args *SayHiArgs
	err = ad.Decode(&args)
	if err != nil {
		return
	}
	err = validate.Struct(args)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	err = v1.h.SayHi(ctx, s, args)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *helloServer) clockTime(s *orbit.Session, stream net.Conn) {
	ret := newTimeWriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret.OnClosing(stream.Close)
	v1.h.ClockTime(s, ret)
}

// ---------------------

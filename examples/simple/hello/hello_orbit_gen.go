/* code generated by orbit */
package hello

import (
	context "context"
	errors "errors"
	fmt "fmt"
	closer "github.com/desertbit/closer/v3"
	oclient "github.com/desertbit/orbit/pkg/client"
	codec "github.com/desertbit/orbit/pkg/codec"
	packet "github.com/desertbit/orbit/pkg/packet"
	oservice "github.com/desertbit/orbit/pkg/service"
	transport "github.com/desertbit/orbit/pkg/transport"
	validator "github.com/go-playground/validator/v10"
	io "io"
	net "net"
	strings "strings"
	sync "sync"
	time "time"
)

// Ensure that all imports are used.
var (
	_ context.Context
	_ = errors.New("")
	_ = fmt.Sprint()
	_ io.Closer
	_ net.Conn
	_ time.Time
	_ strings.Builder
	_ sync.Locker
	_ oclient.Client
	_ closer.Closer
	_ codec.Codec
	_ = packet.MaxSize
	_ oservice.Service
	_ transport.Transport
	_ validator.StructLevel
)

//##############//
//### Errors ###//
//##############//

var ErrClosed = errors.New("closed")

const (
	ErrCodeIAmAnError  = 2
	ErrCodeThisIsATest = 1
)

var (
	ErrIAmAnError         = errors.New("i am an error")
	serviceErrIAmAnError  = oservice.Err(ErrIAmAnError, ErrIAmAnError.Error(), ErrCodeIAmAnError)
	ErrThisIsATest        = errors.New("this is a test")
	serviceErrThisIsATest = oservice.Err(ErrThisIsATest, ErrThisIsATest.Error(), ErrCodeThisIsATest)
)

func _clientErrorCheck(err error) error {
	var cErr oclient.Error
	if errors.As(err, &cErr) {
		switch cErr.Code() {
		case ErrCodeIAmAnError:
			return ErrIAmAnError
		case ErrCodeThisIsATest:
			return ErrThisIsATest
		}
	}
	return err
}

func _serviceErrorCheck(err error) error {
	if errors.Is(err, ErrIAmAnError) {
		return serviceErrIAmAnError
	} else if errors.Is(err, ErrThisIsATest) {
		return serviceErrThisIsATest
	}
	return err
}

func _valErrCheck(err error) error {
	if vErrs, ok := err.(validator.ValidationErrors); ok {
		var errMsg strings.Builder
		for _, err := range vErrs {
			errMsg.WriteString(fmt.Sprintf("-> name: '%s', value: '%s', tag: '%s'", err.StructNamespace(), err.Value(), err.Tag()))
		}
		return errors.New(errMsg.String())
	}
	return err
}

var validate = validator.New()

//#############//
//### Types ###//
//#############//

type Info struct {
	Name    string `validate:"required,min=1"`
	Age     int    `validate:"required,min=1,max=155"`
	Locale  string `validate:"required,len=5"`
	Address string `validate:"omitempty"`
}

type SayHiArg struct {
	Name string `validate:"required,min=1"`
}

type TestRet struct {
	Name string `validate:"required,min=1"`
}

//msgp:ignore InfoReadStream
type InfoReadStream struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newInfoReadStream(cl closer.Closer, stream net.Conn, cc codec.Codec) *InfoReadStream {
	return &InfoReadStream{Closer: cl, stream: stream, codec: cc}
}

func (c *InfoReadStream) Read() (arg *Info, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore InfoWriteStream
type InfoWriteStream struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newInfoWriteStream(cl closer.Closer, stream net.Conn, cc codec.Codec) *InfoWriteStream {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &InfoWriteStream{Closer: cl, stream: stream, codec: cc}
}

func (c *InfoWriteStream) Write(ret *Info) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//msgp:ignore TimeReadStream
type TimeReadStream struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newTimeReadStream(cl closer.Closer, stream net.Conn, cc codec.Codec) *TimeReadStream {
	return &TimeReadStream{Closer: cl, stream: stream, codec: cc}
}

func (c *TimeReadStream) Read() (arg time.Time, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Var(arg, "required")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore TimeWriteStream
type TimeWriteStream struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newTimeWriteStream(cl closer.Closer, stream net.Conn, cc codec.Codec) *TimeWriteStream {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &TimeWriteStream{Closer: cl, stream: stream, codec: cc}
}

func (c *TimeWriteStream) Write(ret time.Time) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//#############//
//### Enums ###//
//#############//

type Vehicle int

const (
	Car    Vehicle = 1
	Pickup Vehicle = 2
)

//###############//
//### Service ###//
//###############//

// CallIDs
const (
	SayHi = "SayHi"
	Test  = "Test"
	// StreamIDs
	Lul        = "Lul"
	TimeStream = "TimeStream"
	ClockTime  = "ClockTime"
)

type Client interface {
	closer.Closer
	// Calls
	SayHi(ctx context.Context, arg *SayHiArg) (err error)
	Test(ctx context.Context) (ret *TestRet, err error)
	// Streams
	Lul(ctx context.Context) (stream transport.Stream, err error)
	TimeStream(ctx context.Context) (arg *InfoWriteStream, err error)
	ClockTime(ctx context.Context) (ret *TimeReadStream, err error)
}

type Service interface {
	closer.Closer
	Run() error
}

type ServiceHandler interface {
	// Calls
	SayHi(ctx oservice.Context, arg *SayHiArg) (err error)
	Test(ctx oservice.Context) (ret *TestRet, err error)
	// Streams
	Lul(ctx oservice.Context, stream transport.Stream)
	TimeStream(ctx oservice.Context, arg *InfoReadStream)
	ClockTime(ctx oservice.Context, ret *TimeWriteStream)
}

type client struct {
	oclient.Client
	codec             codec.Codec
	callTimeout       time.Duration
	streamInitTimeout time.Duration
}

func NewClient(opts *oclient.Options) (c Client, err error) {
	oc, err := oclient.New(opts)
	if err != nil {
		return
	}
	c = &client{Client: oc, codec: opts.Codec, callTimeout: opts.CallTimeout, streamInitTimeout: opts.StreamInitTimeout}
	return
}

func (v1 *client) SayHi(ctx context.Context, arg *SayHiArg) (err error) {
	if v1.callTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.callTimeout)
		defer cancel()
	}
	err = v1.Call(ctx, SayHi, arg, nil)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	return
}

func (v1 *client) Test(ctx context.Context) (ret *TestRet, err error) {
	ctx, cancel := context.WithTimeout(ctx, 500000000*time.Nanosecond)
	defer cancel()
	err = v1.AsyncCall(ctx, Test, nil, &ret)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *client) Lul(ctx context.Context) (stream transport.Stream, err error) {
	if v1.streamInitTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.streamInitTimeout)
		defer cancel()
	}
	stream, err = v1.Stream(ctx, Lul)
	if err != nil {
		return
	}
	return
}

func (v1 *client) TimeStream(ctx context.Context) (arg *InfoWriteStream, err error) {
	if v1.streamInitTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.streamInitTimeout)
		defer cancel()
	}
	stream, err := v1.Stream(ctx, TimeStream)
	if err != nil {
		return
	}
	arg = newInfoWriteStream(v1.CloserOneWay(), stream, v1.codec)
	arg.OnClosing(stream.Close)
	return
}

func (v1 *client) ClockTime(ctx context.Context) (ret *TimeReadStream, err error) {
	if v1.streamInitTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.streamInitTimeout)
		defer cancel()
	}
	stream, err := v1.Stream(ctx, ClockTime)
	if err != nil {
		return
	}
	ret = newTimeReadStream(v1.CloserOneWay(), stream, v1.codec)
	ret.OnClosing(stream.Close)
	return
}

type service struct {
	oservice.Service
	h     ServiceHandler
	codec codec.Codec
}

func NewService(h ServiceHandler, opts *oservice.Options) (s Service, err error) {
	os, err := oservice.New(opts)
	if err != nil {
		return
	}
	srvc := &service{Service: os, h: h, codec: opts.Codec}
	os.RegisterCall(SayHi, srvc.sayHi)
	os.RegisterCall(Test, srvc.test)
	os.RegisterStream(Lul, srvc.lul)
	os.RegisterStream(TimeStream, srvc.timeStream)
	os.RegisterStream(ClockTime, srvc.clockTime)
	s = os
	return
}

func (v1 *service) sayHi(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	var arg *SayHiArg
	err = v1.codec.Decode(argData, &arg)
	if err != nil {
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	err = v1.h.SayHi(ctx, arg)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	return
}

func (v1 *service) test(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	ret, err := v1.h.Test(ctx)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	if ret == nil {
		err = errors.New("return value is a nil pointer")
		return
	}
	retData = ret
	return
}

func (v1 *service) lul(ctx oservice.Context, stream transport.Stream) {
	v1.h.Lul(ctx, stream)
}
func (v1 *service) timeStream(ctx oservice.Context, stream transport.Stream) {
	arg := newInfoReadStream(v1.CloserOneWay(), stream, v1.codec)
	arg.OnClosing(stream.Close)
	v1.h.TimeStream(ctx, arg)
}

func (v1 *service) clockTime(ctx oservice.Context, stream transport.Stream) {
	ret := newTimeWriteStream(v1.CloserOneWay(), stream, v1.codec)
	ret.OnClosing(stream.Close)
	v1.h.ClockTime(ctx, ret)
}

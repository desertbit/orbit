/* code generated by orbit */
package api

import (
	context "context"
	errors "errors"
	fmt "fmt"
	closer "github.com/desertbit/closer/v3"
	codec "github.com/desertbit/orbit/pkg/codec"
	orbit "github.com/desertbit/orbit/pkg/orbit"
	packet "github.com/desertbit/orbit/pkg/packet"
	validator "github.com/go-playground/validator/v10"
	io "io"
	net "net"
	strings "strings"
	sync "sync"
	time "time"
)

var (
	_ context.Context
	_ = errors.New("")
	_ net.Conn
	_ time.Time
	_ sync.Locker
	_ orbit.Conn
	_ = fmt.Sprint()
	_ = strings.Builder{}
	_ = io.EOF
	_ validator.StructLevel
	_ codec.Codec
	_ = packet.MaxSize
	_ closer.Closer
)

//##############//
//### Errors ###//
//##############//

var ErrClosed = errors.New("closed")

const (
	ErrCodeTheFirstError  = 1
	ErrCodeTheSecondError = 2
	ErrCodeTheThirdError  = 3
)

var (
	ErrTheFirstError       = errors.New("the first error")
	orbitErrTheFirstError  = orbit.Err(ErrTheFirstError, ErrTheFirstError.Error(), ErrCodeTheFirstError)
	ErrTheSecondError      = errors.New("the second error")
	orbitErrTheSecondError = orbit.Err(ErrTheSecondError, ErrTheSecondError.Error(), ErrCodeTheSecondError)
	ErrTheThirdError       = errors.New("the third error")
	orbitErrTheThirdError  = orbit.Err(ErrTheThirdError, ErrTheThirdError.Error(), ErrCodeTheThirdError)
)

func _orbitErrCodeCheck(err error) error {
	var cErr *orbit.ErrorCode
	if errors.As(err, &cErr) {
		switch cErr.Code {
		case ErrCodeTheFirstError:
			return ErrTheFirstError
		case ErrCodeTheSecondError:
			return ErrTheSecondError
		case ErrCodeTheThirdError:
			return ErrTheThirdError
		}
	}
	return err
}

func _errToOrbitErrCodeCheck(err error) error {
	if errors.Is(err, ErrTheFirstError) {
		return orbitErrTheFirstError
	} else if errors.Is(err, ErrTheSecondError) {
		return orbitErrTheSecondError
	} else if errors.Is(err, ErrTheThirdError) {
		return orbitErrTheThirdError
	}
	return err
}

func _valErrCheck(err error) error {
	if vErrs, ok := err.(validator.ValidationErrors); ok {
		var errMsg strings.Builder
		for _, err := range vErrs {
			errMsg.WriteString(fmt.Sprintf("-> name: '%s', value: '%s', tag: '%s'", err.StructNamespace(), err.Value(), err.Tag()))
		}
		return errors.New(errMsg.String())
	}
	return err
}

var validate = validator.New()

//#############//
//### Types ###//
//#############//

type Args struct {
	Crazy map[string][][]map[string]En1
	I     int
	M     map[string]int `validate:"required"`
	S     string
	Sl    []time.Time
	St    *Ret
}

type Rc1Ret struct {
	Crazy map[string][][]map[string]En1
	I     int
	M     map[string]int
	S     string `validate:"email"`
	Sl    []time.Time
	St    *Ret
}

type Rc2Args struct {
	B   byte
	F   float64 `validate:"gte=-1"`
	U16 uint16
	U32 uint32
	U64 uint64
	U8  uint8
}

type Ret struct {
	B   byte    `validate:"required,dive,required"`
	F   float64 `validate:"gte=0,lte=130"`
	U16 uint16
	U32 uint32
	U64 uint64
	U8  uint8
}

//msgp:ignore StringReadChan
type StringReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newStringReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *StringReadChan {
	return &StringReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *StringReadChan) Read() (arg string, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Var(arg, "omitempty,email")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore StringWriteChan
type StringWriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newStringWriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *StringWriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &StringWriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *StringWriteChan) Write(ret string) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//msgp:ignore En1ReadChan
type En1ReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newEn1ReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *En1ReadChan {
	return &En1ReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *En1ReadChan) Read() (arg En1, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Var(arg, "required")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore En1WriteChan
type En1WriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newEn1WriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *En1WriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &En1WriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *En1WriteChan) Write(ret En1) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//msgp:ignore ArgsReadChan
type ArgsReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newArgsReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *ArgsReadChan {
	return &ArgsReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *ArgsReadChan) Read() (arg *Args, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore ArgsWriteChan
type ArgsWriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newArgsWriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *ArgsWriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &ArgsWriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *ArgsWriteChan) Write(ret *Args) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//msgp:ignore RetReadChan
type RetReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newRetReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *RetReadChan {
	return &RetReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *RetReadChan) Read() (arg *Ret, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore RetWriteChan
type RetWriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newRetWriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *RetWriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &RetWriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *RetWriteChan) Write(ret *Ret) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//msgp:ignore MapStringIntReadChan
type MapStringIntReadChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newMapStringIntReadChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *MapStringIntReadChan {
	return &MapStringIntReadChan{Closer: cl, stream: stream, codec: cc}
}

func (c *MapStringIntReadChan) Read() (arg map[string]int, err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.ReadDecode(c.stream, &arg, c.codec)
	if err != nil {
		if errors.Is(err, packet.ErrZeroData) || errors.Is(err, io.EOF) {
			err = ErrClosed
		}
		c.Close_()
		return
	}
	err = validate.Var(arg, "omitempty")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

//msgp:ignore MapStringIntWriteChan
type MapStringIntWriteChan struct {
	closer.Closer
	stream net.Conn
	codec  codec.Codec
}

func newMapStringIntWriteChan(cl closer.Closer, stream net.Conn, cc codec.Codec) *MapStringIntWriteChan {
	cl.OnClosing(func() error { return packet.Write(stream, nil) })
	return &MapStringIntWriteChan{Closer: cl, stream: stream, codec: cc}
}

func (c *MapStringIntWriteChan) Write(ret map[string]int) (err error) {
	if c.IsClosing() {
		err = ErrClosed
		return
	}
	err = packet.WriteEncode(c.stream, ret, c.codec)
	if err != nil {
		if errors.Is(err, io.EOF) {
			c.Close_()
			return ErrClosed
		}
	}
	return
}

//#############//
//### Enums ###//
//#############//

type En1 int

const (
	Val1 En1 = 1
	Val2 En1 = 2
	Val3 En1 = 3
)

//################//
//### Services ###//
//################//

// S1  ---------------------
// Service
const (
	ServiceS1 = "S1"
	S1C1      = "C1"
	S1C2      = "C2"
	S1C3      = "C3"
	S1Rc1     = "Rc1"
	S1Rc2     = "Rc2"
	S1Rc3     = "Rc3"
	S1S1      = "S1"
	S1S2      = "S2"
	S1S3      = "S3"
	S1Rs1     = "Rs1"
	S1Rs2     = "Rs2"
	S1Rs3     = "Rs3"
)

type S1ClientCaller interface {
	// Calls
	C1(ctx context.Context, args int) (ret float32, err error)
	C2(ctx context.Context, args time.Time) (ret []map[string][]*Ret, err error)
	C3(ctx context.Context) (err error)
	// Streams
	S1(ctx context.Context) (stream net.Conn, err error)
	S2(ctx context.Context) (args *StringWriteChan, err error)
	S3(ctx context.Context) (ret *En1ReadChan, err error)
}

type S1ClientHandler interface {
	// Calls
	Rc1(ctx context.Context, s *orbit.Session, args *Args) (ret *Rc1Ret, err error)
	Rc2(ctx context.Context, s *orbit.Session, args *Rc2Args) (err error)
	Rc3(ctx context.Context, s *orbit.Session) (err error)
	// Streams
	Rs1(s *orbit.Session, args *ArgsReadChan, ret *RetWriteChan)
	Rs2(s *orbit.Session, args *MapStringIntReadChan)
	Rs3(s *orbit.Session, stream net.Conn)
}

type S1ServerCaller interface {
	// Calls
	Rc1(ctx context.Context, args *Args) (ret *Rc1Ret, err error)
	Rc2(ctx context.Context, args *Rc2Args) (err error)
	Rc3(ctx context.Context) (err error)
	// Streams
	Rs1(ctx context.Context) (args *ArgsWriteChan, ret *RetReadChan, err error)
	Rs2(ctx context.Context) (args *MapStringIntWriteChan, err error)
	Rs3(ctx context.Context) (stream net.Conn, err error)
}

type S1ServerHandler interface {
	// Calls
	C1(ctx context.Context, s *orbit.Session, args int) (ret float32, err error)
	C2(ctx context.Context, s *orbit.Session, args time.Time) (ret []map[string][]*Ret, err error)
	C3(ctx context.Context, s *orbit.Session) (err error)
	// Streams
	S1(s *orbit.Session, stream net.Conn)
	S2(s *orbit.Session, args *StringReadChan)
	S3(s *orbit.Session, ret *En1WriteChan)
}

type s1Client struct {
	h S1ClientHandler
	s *orbit.Session
}

func RegisterS1Client(s *orbit.Session, h S1ClientHandler) S1ClientCaller {
	cc := &s1Client{h: h, s: s}
	s.RegisterCall(ServiceS1, S1Rc1, cc.rc1)
	s.RegisterCall(ServiceS1, S1Rc2, cc.rc2)
	s.RegisterCall(ServiceS1, S1Rc3, cc.rc3)
	s.RegisterStream(ServiceS1, S1Rs1, cc.rs1)
	s.RegisterStream(ServiceS1, S1Rs2, cc.rs2)
	s.RegisterStream(ServiceS1, S1Rs3, cc.rs3)
	return cc
}

func (v1 *s1Client) C1(ctx context.Context, args int) (ret float32, err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	retData, err := v1.s.Call(ctx, ServiceS1, S1C1, args)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	err = retData.Decode(&ret)
	if err != nil {
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *s1Client) C2(ctx context.Context, args time.Time) (ret []map[string][]*Ret, err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	retData, err := v1.s.CallAsync(ctx, ServiceS1, S1C2, args)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	err = retData.Decode(&ret)
	if err != nil {
		return
	}
	err = validate.Var(ret, "required,dive,required")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *s1Client) C3(ctx context.Context) (err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	_, err = v1.s.Call(ctx, ServiceS1, S1C3, nil)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Client) rc1(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	var args *Args
	err = ad.Decode(&args)
	if err != nil {
		return
	}
	err = validate.Struct(args)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	ret, err := v1.h.Rc1(ctx, s, args)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	r = ret
	return
}

func (v1 *s1Client) rc2(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	var args *Rc2Args
	err = ad.Decode(&args)
	if err != nil {
		return
	}
	err = validate.Struct(args)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	err = v1.h.Rc2(ctx, s, args)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Client) rc3(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	err = v1.h.Rc3(ctx, s)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Client) S1(ctx context.Context) (stream net.Conn, err error) {
	return v1.s.OpenStream(ctx, ServiceS1, S1S1)
}

func (v1 *s1Client) S2(ctx context.Context) (args *StringWriteChan, err error) {
	stream, err := v1.s.OpenStream(ctx, ServiceS1, S1S2)
	if err != nil {
		return
	}
	args = newStringWriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	args.OnClosing(stream.Close)
	return
}

func (v1 *s1Client) S3(ctx context.Context) (ret *En1ReadChan, err error) {
	stream, err := v1.s.OpenStream(ctx, ServiceS1, S1S3)
	if err != nil {
		return
	}
	ret = newEn1ReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret.OnClosing(stream.Close)
	return
}

func (v1 *s1Client) rs1(s *orbit.Session, stream net.Conn) {
	args := newArgsReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret := newRetWriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	go func() {
		<-args.ClosedChan()
		<-ret.ClosedChan()
		_ = stream.Close()
	}()
	v1.h.Rs1(s, args, ret)
}

func (v1 *s1Client) rs2(s *orbit.Session, stream net.Conn) {
	args := newMapStringIntReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	args.OnClosing(stream.Close)
	v1.h.Rs2(s, args)
}

func (v1 *s1Client) rs3(s *orbit.Session, stream net.Conn) {
	v1.h.Rs3(s, stream)
}

type s1Server struct {
	h S1ServerHandler
	s *orbit.Session
}

func RegisterS1Server(s *orbit.Session, h S1ServerHandler) S1ServerCaller {
	cc := &s1Server{h: h, s: s}
	s.RegisterCall(ServiceS1, S1C1, cc.c1)
	s.RegisterCall(ServiceS1, S1C2, cc.c2)
	s.RegisterCall(ServiceS1, S1C3, cc.c3)
	s.RegisterStream(ServiceS1, S1S1, cc.s1)
	s.RegisterStream(ServiceS1, S1S2, cc.s2)
	s.RegisterStream(ServiceS1, S1S3, cc.s3)
	return cc
}

func (v1 *s1Server) Rc1(ctx context.Context, args *Args) (ret *Rc1Ret, err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	retData, err := v1.s.Call(ctx, ServiceS1, S1Rc1, args)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	err = retData.Decode(&ret)
	if err != nil {
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *s1Server) Rc2(ctx context.Context, args *Rc2Args) (err error) {
	ctx, cancel := context.WithTimeout(ctx, 500000000*time.Nanosecond)
	defer cancel()
	_, err = v1.s.CallAsync(ctx, ServiceS1, S1Rc2, args)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Server) Rc3(ctx context.Context) (err error) {
	ct := v1.s.CallTimeout()
	if ct > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, ct)
		defer cancel()
	}
	_, err = v1.s.Call(ctx, ServiceS1, S1Rc3, nil)
	if err != nil {
		err = _orbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Server) c1(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	var args int
	err = ad.Decode(&args)
	if err != nil {
		return
	}
	err = validate.Var(args, "gte=0")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	ret, err := v1.h.C1(ctx, s, args)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	r = ret
	return
}

func (v1 *s1Server) c2(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	var args time.Time
	err = ad.Decode(&args)
	if err != nil {
		return
	}
	err = validate.Var(args, "required")
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	ret, err := v1.h.C2(ctx, s, args)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	r = ret
	return
}

func (v1 *s1Server) c3(ctx context.Context, s *orbit.Session, ad *orbit.Data) (r interface{}, err error) {
	err = v1.h.C3(ctx, s)
	if err != nil {
		err = _errToOrbitErrCodeCheck(err)
		return
	}
	return
}

func (v1 *s1Server) Rs1(ctx context.Context) (args *ArgsWriteChan, ret *RetReadChan, err error) {
	stream, err := v1.s.OpenStream(ctx, ServiceS1, S1Rs1)
	if err != nil {
		return
	}
	args = newArgsWriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret = newRetReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	go func() {
		<-args.ClosedChan()
		<-ret.ClosedChan()
		_ = stream.Close()
	}()
	return
}

func (v1 *s1Server) Rs2(ctx context.Context) (args *MapStringIntWriteChan, err error) {
	stream, err := v1.s.OpenStream(ctx, ServiceS1, S1Rs2)
	if err != nil {
		return
	}
	args = newMapStringIntWriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	args.OnClosing(stream.Close)
	return
}

func (v1 *s1Server) Rs3(ctx context.Context) (stream net.Conn, err error) {
	return v1.s.OpenStream(ctx, ServiceS1, S1Rs3)
}

func (v1 *s1Server) s1(s *orbit.Session, stream net.Conn) {
	v1.h.S1(s, stream)
}
func (v1 *s1Server) s2(s *orbit.Session, stream net.Conn) {
	args := newStringReadChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	args.OnClosing(stream.Close)
	v1.h.S2(s, args)
}

func (v1 *s1Server) s3(s *orbit.Session, stream net.Conn) {
	ret := newEn1WriteChan(v1.s.CloserOneWay(), stream, v1.s.Codec())
	ret.OnClosing(stream.Close)
	v1.h.S3(s, ret)
}

// ---------------------

/* code generated by orbit */
package call

import (
	context "context"
	errors "errors"
	fmt "fmt"
	closer "github.com/desertbit/closer/v3"
	oclient "github.com/desertbit/orbit/pkg/client"
	codec "github.com/desertbit/orbit/pkg/codec"
	packet "github.com/desertbit/orbit/pkg/packet"
	oservice "github.com/desertbit/orbit/pkg/service"
	transport "github.com/desertbit/orbit/pkg/transport"
	validator "github.com/go-playground/validator/v10"
	io "io"
	net "net"
	strings "strings"
	sync "sync"
	time "time"
)

// Ensure that all imports are used.
var (
	_ context.Context
	_ = errors.New("")
	_ = fmt.Sprint()
	_ io.Closer
	_ net.Conn
	_ time.Time
	_ strings.Builder
	_ sync.Locker
	_ oclient.Client
	_ closer.Closer
	_ codec.Codec
	_ = packet.MaxSize
	_ oservice.Service
	_ transport.Transport
	_ validator.StructLevel
)

//##############//
//### Errors ###//
//##############//

var ErrClosed = errors.New("closed")

func _clientErrorCheck(err error) error {
	return err
}
func _serviceErrorCheck(err error) error {
	return err
}
func _valErrCheck(err error) error {
	if vErrs, ok := err.(validator.ValidationErrors); ok {
		var errMsg strings.Builder
		for _, err := range vErrs {
			errMsg.WriteString(fmt.Sprintf("[name: '%s', value: '%s', tag: '%s']", err.StructNamespace(), err.Value(), err.Tag()))
		}
		return errors.New(errMsg.String())
	}
	return err
}

var validate = validator.New()

//#############//
//### Types ###//
//#############//

type ArgDataArg struct {
	Data []byte
}

type ArgRetDataArg struct {
	Data float64
}

type ArgRetDataRet struct {
	Data1 time.Time
	Data2 []map[string][]bool
}

type RetDataRet struct {
	Data map[string][]int
}

//###############//
//### Service ###//
//###############//

const (
	CallIDNoData     = "NoData"
	CallIDArgData    = "ArgData"
	CallIDRetData    = "RetData"
	CallIDArgRetData = "ArgRetData"
)

type Client interface {
	closer.Closer
	StateChan() <-chan oclient.State
	// Calls
	NoData(ctx context.Context) (err error)
	ArgData(ctx context.Context, arg ArgDataArg) (err error)
	RetData(ctx context.Context) (ret RetDataRet, err error)
	ArgRetData(ctx context.Context, arg ArgRetDataArg) (ret ArgRetDataRet, err error)
}

type Service interface {
	closer.Closer
	Run() error
}

type ServiceHandler interface {
	// Calls
	NoData(ctx oservice.Context) (err error)
	ArgData(ctx oservice.Context, arg ArgDataArg) (err error)
	RetData(ctx oservice.Context) (ret RetDataRet, err error)
	ArgRetData(ctx oservice.Context, arg ArgRetDataArg) (ret ArgRetDataRet, err error)
}

type client struct {
	oclient.Client
	codec             codec.Codec
	callTimeout       time.Duration
	streamInitTimeout time.Duration
	maxArgSize        int
	maxRetSize        int
}

func NewClient(opts *oclient.Options) (c Client, err error) {
	oc, err := oclient.New(opts)
	if err != nil {
		return
	}
	c = &client{Client: oc, codec: opts.Codec, callTimeout: opts.CallTimeout, streamInitTimeout: opts.StreamInitTimeout, maxArgSize: opts.MaxArgSize, maxRetSize: opts.MaxRetSize}
	return
}

func (v1 *client) StateChan() <-chan oclient.State {
	return v1.Client.StateChan()
}

func (v1 *client) NoData(ctx context.Context) (err error) {
	if v1.callTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.callTimeout)
		defer cancel()
	}
	err = v1.Call(ctx, CallIDNoData, nil, nil)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	return
}

func (v1 *client) ArgData(ctx context.Context, arg ArgDataArg) (err error) {
	if v1.callTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.callTimeout)
		defer cancel()
	}
	err = v1.Call(ctx, CallIDArgData, arg, nil)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	return
}

func (v1 *client) RetData(ctx context.Context) (ret RetDataRet, err error) {
	if v1.callTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.callTimeout)
		defer cancel()
	}
	err = v1.Call(ctx, CallIDRetData, nil, &ret)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

func (v1 *client) ArgRetData(ctx context.Context, arg ArgRetDataArg) (ret ArgRetDataRet, err error) {
	if v1.callTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, v1.callTimeout)
		defer cancel()
	}
	err = v1.Call(ctx, CallIDArgRetData, arg, &ret)
	if err != nil {
		err = _clientErrorCheck(err)
		return
	}
	err = validate.Struct(ret)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	return
}

type service struct {
	oservice.Service
	h          ServiceHandler
	codec      codec.Codec
	maxArgSize int
	maxRetSize int
}

func NewService(h ServiceHandler, opts *oservice.Options) (s Service, err error) {
	os, err := oservice.New(opts)
	if err != nil {
		return
	}
	srvc := &service{Service: os, h: h, codec: opts.Codec, maxArgSize: opts.MaxArgSize, maxRetSize: opts.MaxRetSize}
	// Ensure usage.
	_ = srvc
	os.RegisterCall(CallIDNoData, srvc.noData, oservice.DefaultTimeout)
	os.RegisterCall(CallIDArgData, srvc.argData, oservice.DefaultTimeout)
	os.RegisterCall(CallIDRetData, srvc.retData, oservice.DefaultTimeout)
	os.RegisterCall(CallIDArgRetData, srvc.argRetData, oservice.DefaultTimeout)
	s = os
	return
}

func (v1 *service) noData(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	err = v1.h.NoData(ctx)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	return
}

func (v1 *service) argData(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	var arg ArgDataArg
	err = v1.codec.Decode(argData, &arg)
	if err != nil {
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	err = v1.h.ArgData(ctx, arg)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	return
}

func (v1 *service) retData(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	ret, err := v1.h.RetData(ctx)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	retData = &ret
	return
}

func (v1 *service) argRetData(ctx oservice.Context, argData []byte) (retData interface{}, err error) {
	var arg ArgRetDataArg
	err = v1.codec.Decode(argData, &arg)
	if err != nil {
		return
	}
	err = validate.Struct(arg)
	if err != nil {
		err = _valErrCheck(err)
		return
	}
	ret, err := v1.h.ArgRetData(ctx, arg)
	if err != nil {
		err = _serviceErrorCheck(err)
		return
	}
	retData = &ret
	return
}
